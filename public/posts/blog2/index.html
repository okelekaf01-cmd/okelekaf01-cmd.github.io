<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>预设代码、Skill 与 MCP | wwxdsg的个人博客</title><meta name=keywords content="AI,架构设计,技术模式"><meta name=description content="探讨AI应用开发中三种技术模式：预设代码、Skill和MCP的本质区别与适用场景"><meta name=author content="wwxdsg"><link rel=canonical href=https://okelekaf01-cmd.github.io/posts/blog2/><link crossorigin=anonymous href=/assets/css/stylesheet.a29c24210eb31d9ce56f669c66a35c9c51b17376b7764e336a49af7dec914cf0.css integrity="sha256-opwkIQ6zHZzlb2acZqNcnFGxc3a3dk4zakmvfeyRTPA=" rel="preload stylesheet" as=style><link rel=icon href=https://okelekaf01-cmd.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://okelekaf01-cmd.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://okelekaf01-cmd.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://okelekaf01-cmd.github.io/apple-touch-icon.png><link rel=mask-icon href=https://okelekaf01-cmd.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://okelekaf01-cmd.github.io/posts/blog2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://okelekaf01-cmd.github.io/posts/blog2/"><meta property="og:site_name" content="wwxdsg的个人博客"><meta property="og:title" content="预设代码、Skill 与 MCP"><meta property="og:description" content="探讨AI应用开发中三种技术模式：预设代码、Skill和MCP的本质区别与适用场景"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-07T14:00:00+08:00"><meta property="article:modified_time" content="2026-02-07T14:00:00+08:00"><meta property="article:tag" content="AI"><meta property="article:tag" content="架构设计"><meta property="article:tag" content="技术模式"><meta name=twitter:card content="summary"><meta name=twitter:title content="预设代码、Skill 与 MCP"><meta name=twitter:description content="探讨AI应用开发中三种技术模式：预设代码、Skill和MCP的本质区别与适用场景"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://okelekaf01-cmd.github.io/posts/"},{"@type":"ListItem","position":2,"name":"预设代码、Skill 与 MCP","item":"https://okelekaf01-cmd.github.io/posts/blog2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"预设代码、Skill 与 MCP","name":"预设代码、Skill 与 MCP","description":"探讨AI应用开发中三种技术模式：预设代码、Skill和MCP的本质区别与适用场景","keywords":["AI","架构设计","技术模式"],"articleBody":"本文以我的开源项目 OpsMind 为例，探讨 AI 应用开发中三种常见的技术模式：预设代码、Skill 和 MCP，分析它们的本质区别与适用场景。\n最近在开发 OpsMind —— 一个智能运营决策中枢，核心功能是通过自然语言对话进行数据分析和文件生成。在研究 AI 应用架构时，我接触到了 Skill 和 MCP 两个概念。 起初我有些困惑：我的项目也能通过对话生成文件，这和 MCP 有什么区别？预设代码算不算 Skill 技术？这些技术和提示词工程又是什么关系？\n我的现状：预设代码模式 项目架构 OpsMind 目前的核心是一个 DataAnalysisEngine 类，所有功能都硬编码在类方法中：\nclass DataAnalysisEngine: \"\"\"数据分析引擎类\"\"\" def generate_charts(self, df, chart_types): \"\"\"生成图表\"\"\" if \"histogram\" in chart_types: plt.hist(...) # 直方图 if \"scatter\" in chart_types: plt.scatter(...) # 散点图 if \"heatmap\" in chart_types: sns.heatmap(...) # 热力图 # ... 更多图表类型 def generate_tables(self, df, table_types): \"\"\"生成表格\"\"\" if \"basic_stats\" in table_types: df.describe().to_excel(...) # 统计表 if \"pivot\" in table_types: df.pivot_table(...).to_excel(...) # 透视表 # ... 更多表格类型 执行流程 用户说\"帮我分析销售数据并生成图表\"，整个流程如下：\n┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ 用户输入 │ ──→ │ LLM 判断 │ ──→ │ 调用预设 │ ──→ │ 生成文件 │ │ │ │ 意图 │ │ 函数 │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘ LLM 的作用是判断用户想要什么类型的图表/表格，然后调用对应的 Python 函数执行。\n这种模式的特点 优点 缺点 开发简单，逻辑清晰 功能固定，扩展需改代码 性能好，无额外开销 无法被其他 AI 应用复用 功能可控，调试方便 所有功能耦合在一起 我把这种模式称为预设代码模式——功能写死在代码里，调用时直接执行。\nSkill 技术：动态能力注入 什么是 Skill Skill 是一种运行时动态加载能力的模式。与预设代码不同，Skill 不是把所有功能都写死在启动时加载，而是根据用户需求，按需激活对应的能力模块。\n如果用 Skill 重构 OpsMind skills/ ├── data_analysis/ │ └── skill.md # 数据分析能力 ├── chart_generation/ │ └── skill.md # 图表生成能力 └── table_export/ └── skill.md # 表格导出能力 每个 Skill 文件包含：\n# 图表生成 Skill ## 触发条件 用户要求生成图表、可视化数据时激活 ## Prompt 模板 你是一个数据可视化专家，可以生成以下图表： - 直方图：调用 generate_histogram(data, column) - 散点图：调用 generate_scatter(data, x_col, y_col) - 热力图：调用 generate_heatmap(data, columns) ## 工具定义 - generate_histogram(data, column): 生成指定列的直方图 - generate_scatter(data, x_col, y_col): 生成散点图 - generate_heatmap(data, columns): 生成相关性热力图 执行流程对比 预设代码模式：\n启动时加载所有功能 → 用户提问 → LLM 选择函数 → 执行 Skill 模式：\n启动时加载基础能力 → 用户提问 → 识别需要哪个 Skill → 动态注入 Skill → LLM 使用 Skill 中的工具 → 执行 与预设代码的对比 维度 预设代码 Skill 加载时机 启动时全部加载 运行时按需加载 Prompt 位置 固定在代码里 动态注入上下文 扩展方式 修改源代码 添加 Skill 文件 隔离性 功能耦合 模块独立 复用性 仅限本项目 可跨项目复用 我的理解：Skill 本质上是把\"能力\"抽象成可插拔的模块，让 AI Agent 能够根据任务动态组装自己的能力集。\nMCP：跨应用工具共享协议 什么是 MCP MCP（Model Context Protocol）是 Anthropic 推出的开放协议，让 AI 应用能够调用外部工具。与 Skill 不同，MCP 关注的是跨应用的能力共享。\n如果用 MCP 重构 OpsMind 我可以把数据分析能力封装成 MCP Server：\n# mcp_server.py from mcp import Server server = Server(\"opsmind-data-analysis\") @server.tool(\"analyze_excel\") def analyze_excel(file_path: str, query: str) -\u003e dict: \"\"\" 分析 Excel 文件并返回结果 Args: file_path: Excel 文件路径 query: 分析需求描述 Returns: 包含分析结果的字典 \"\"\" df = pd.read_excel(file_path) # 分析逻辑... return {\"result\": analysis_result} @server.tool(\"generate_chart\") def generate_chart(data_path: str, chart_type: str, columns: list) -\u003e str: \"\"\" 生成图表并返回文件路径 Args: data_path: 数据文件路径 chart_type: 图表类型 (histogram/scatter/heatmap) columns: 要分析的列名 Returns: 生成的图表文件路径 \"\"\" # 图表生成逻辑... return chart_path MCP 的核心价值 ┌─────────────────────────────────────────────────────────────┐ │ MCP 生态 │ ├─────────────────────────────────────────────────────────────┤ │ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ Claude │ │ Cursor │ │ Trae │ │ │ │ (Client) │ │ (Client) │ │ (Client) │ │ │ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ │ │ │ │ │ │ │ └─────────────────┼─────────────────┘ │ │ │ │ │ ▼ │ │ ┌─────────────────┐ │ │ │ MCP Protocol │ │ │ └────────┬────────┘ │ │ │ │ │ ┌─────────────────┼─────────────────┐ │ │ │ │ │ │ │ ▼ ▼ ▼ │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ │ │ │ OpsMind │ │ 文件系统 │ │ 数据库 │ │ │ │ (Server) │ │ (Server) │ │ (Server) │ │ │ └─────────────┘ └─────────────┘ └─────────────┘ │ │ │ └─────────────────────────────────────────────────────────────┘ 这样，任何支持 MCP 的 AI 应用都能直接使用 OpsMind 的数据分析工具，无需重复开发。\n与 Skill 的对比 维度 Skill MCP 作用范围 单个 AI 应用内部 跨应用共享 工具位置 应用内 独立进程 协议标准 无统一标准 统一开放协议 适用场景 能力模块化 工具生态化 开发成本 较低 需要实现协议 我的理解：MCP 解决的是\"工具孤岛\"问题——让不同 AI 应用能够共享同一套工具，而不是每个应用都重复开发。\n三者的本质区别 架构对比图 ┌─────────────────────────────────────────────────────────────────┐ │ │ │ 【预设代码】 │ │ │ │ ┌─────────────────────────────────────────────────────────┐ │ │ │ AI 应用 │ │ │ │ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ │ │ │ │ 功能 A │ │ 功能 B │ │ 功能 C │ ← 全部硬编码 │ │ │ │ └─────────┘ └─────────┘ └─────────┘ │ │ │ └─────────────────────────────────────────────────────────┘ │ │ │ ├─────────────────────────────────────────────────────────────────┤ │ │ │ 【Skill】 │ │ │ │ ┌─────────────────────────────────────────────────────────┐ │ │ │ AI 应用 │ │ │ │ ┌─────────┐ │ │ │ │ │ 基础能力 │ ←── 动态加载 ───┐ │ │ │ │ └─────────┘ │ │ │ │ └───────────────────────────────┼─────────────────────────┘ │ │ │ │ │ ┌───────────────┬───────────────┴───────────────┐ │ │ │ Skill A │ Skill B │ Skill C │ │ │ │ (按需加载) │ (按需加载) │ (按需加载) │ │ │ └───────────────┴───────────────┴───────────────┘ │ │ │ ├─────────────────────────────────────────────────────────────────┤ │ │ │ 【MCP】 │ │ │ │ ┌─────────────────┐ ┌─────────────────┐ │ │ │ AI 应用 A │ │ AI 应用 B │ │ │ │ (MCP Client) │ │ (MCP Client) │ │ │ └────────┬────────┘ └────────┬────────┘ │ │ │ │ │ │ └───────────┬───────────────┘ │ │ │ │ │ ▼ │ │ ┌─────────────────────┐ │ │ │ MCP Protocol │ │ │ └──────────┬──────────┘ │ │ │ │ │ ┌─────────────┼─────────────┐ │ │ │ │ │ │ │ ▼ ▼ ▼ │ │ ┌───────────┐ ┌───────────┐ ┌───────────┐ │ │ │MCP Server │ │MCP Server │ │MCP Server │ │ │ │ (工具1) │ │ (工具2) │ │ (工具3) │ │ │ └───────────┘ └───────────┘ └───────────┘ │ │ │ └─────────────────────────────────────────────────────────────────┘ 核心差异总结 维度 预设代码 Skill MCP 设计目标 快速实现功能 模块化能力管理 跨应用工具共享 工具位置 应用内部 应用内部 独立进程 加载方式 启动时全部加载 运行时按需加载 通过协议调用 扩展方式 修改源代码 添加 Skill 文件 连接新 Server 共享能力 无法共享 应用内共享 跨应用共享 开发成本 低 中 高 适用规模 小型项目 中型项目 大型生态 提示词与执行层的关系 一个关键问题 在研究这些技术时，我曾有一个疑问：这些技术都可以算是集成的提示词吗？\n答案是：不完全是，但都和提示词相关。\n分层理解 ┌─────────────────────────────────────────────────────────┐ │ │ │ ┌─────────────────────────────────────────────────┐ │ │ │ LLM（大语言模型） │ │ │ └─────────────────────────────────────────────────┘ │ │ │ │ │ ▼ │ │ ┌─────────────────────────────────────────────────┐ │ │ │ 【提示词层】决定 LLM 知道什么 │ │ │ │ │ │ │ │ - 告诉 LLM 有哪些能力可用 │ │ │ │ - 告诉 LLM 如何调用这些能力 │ │ │ │ - 告诉 LLM 参数格式和返回格式 │ │ │ └─────────────────────────────────────────────────┘ │ │ │ │ │ ▼ │ │ ┌─────────────────────────────────────────────────┐ │ │ │ 【执行层】决定实际做什么 │ │ │ │ │ │ │ │ - 预设代码：应用内的 Python 函数 │ │ │ │ - Skill：应用内的模块化函数 │ │ │ │ - MCP：外部独立进程 │ │ │ └─────────────────────────────────────────────────┘ │ │ │ └─────────────────────────────────────────────────────────┘ 以 OpsMind 为例 预设代码模式：\n# 提示词部分：告诉 LLM 有哪些图表类型可选 prompt = \"\"\" 【可选图表类型】 - histogram: 直方图 - 查看数值分布 - scatter: 散点图 - 查看变量关系 - heatmap: 热力图 - 查看特征相关性 \"\"\" # 执行部分：Python 代码直接执行 if \"histogram\" in chart_types: plt.hist(...) # ← 这不是提示词，是真正的代码执行 Skill 模式：\n# 图表生成 Skill 你是一个数据可视化专家，可以生成以下图表： - 直方图：调用 generate_histogram(data, column) - 散点图：调用 generate_scatter(data, x_col, y_col) MCP 模式：\n# MCP Server 定义工具 @server.tool(\"generate_chart\") def generate_chart(data_path: str, chart_type: str) -\u003e str: \"\"\"生成图表并返回文件路径\"\"\" # ← 这个描述会变成提示词 # 实际执行代码 return chart_path # LLM 收到的提示词： # 你可以使用以下工具： # - generate_chart: 生成图表，参数：data_path, chart_type 形象比喻 概念 比喻 作用 提示词 菜单 告诉客人（LLM）有什么菜 预设代码/Skill/MCP 厨房 真正做菜的地方 关键理解：\n提示词是 LLM 的\"说明书\"——告诉它能做什么 预设代码/Skill/MCP 是执行层——真正干活的代码 这三种技术都依赖提示词让 LLM 知道有什么能力可用，但不是提示词本身 技术选型建议 场景匹配 场景 推荐模式 理由 快速开发 MVP 预设代码 开发成本低，迭代快 功能相对固定 预设代码 无需复杂架构 需要模块化扩展 Skill 能力可插拔，易维护 多团队协作开发 Skill 模块独立，职责清晰 需要跨应用共享工具 MCP 一次开发，多处使用 构建工具生态 MCP 开放协议，生态共赢 OpsMind 的演进方向 目前 OpsMind 使用预设代码模式，对于单一应用来说已经足够。但未来可以考虑：\n┌─────────────────────────────────────────────────────────────┐ │ OpsMind 架构演进 │ ├─────────────────────────────────────────────────────────────┤ │ │ │ 第一阶段：预设代码（当前） │ │ ├── 快速实现核心功能 │ │ ├── 验证产品价值 │ │ └── 积累用户反馈 │ │ │ │ 第二阶段：引入 Skill │ │ ├── 模块化现有功能 │ │ ├── 支持第三方 Skill 扩展 │ │ └── 提升可维护性 │ │ │ │ 第三阶段：MCP Server │ │ ├── 开放数据分析能力给其他 AI 应用 │ │ ├── 接入 MCP 生态 │ │ └── 构建工具生态 │ │ │ └─────────────────────────────────────────────────────────────┘ 组合使用 三者并非互斥，可以组合使用：\nAI 应用 → Skill（动态加载能力）→ MCP Client → MCP Server（调用外部工具） 例如：\nOpsMind 作为 AI 应用 使用 Skill 管理内部能力模块 通过 MCP Client 连接外部工具（如数据库、文件系统） 同时作为 MCP Server 对外提供服务 总结 核心观点 预设代码：功能写死在代码里，简单直接，适合快速开发和功能固定的场景。\nSkill：动态能力注入，按需加载，适合模块化设计和需要扩展的场景。\nMCP：跨应用工具共享，开放协议，适合构建工具生态和跨应用复用。\n提示词与执行层：提示词是 LLM 的\"说明书\"，预设代码/Skill/MCP 是真正干活的\"执行层\"，两者配合才能让 AI 应用具备实际能力。\n架构演进路径 预设代码 → Skill → MCP ↓ ↓ ↓ 功能固定 能力模块化 工具生态化 ↓ ↓ ↓ 单应用内 单应用内 跨应用共享 ↓ ↓ ↓ 改代码扩展 加文件扩展 连接新Server 最后的话 没有最好的架构，只有最适合的架构。理解每种模式的适用场景，才能做出正确的技术选型。\n对于 OpsMind 这样的项目，从预设代码开始是正确的选择——先验证价值，再考虑架构演进。当功能逐渐丰富、用户需求多样化时，再引入 Skill 和 MCP，逐步构建更开放、更可扩展的架构。\n","wordCount":"1170","inLanguage":"en","datePublished":"2026-02-07T14:00:00+08:00","dateModified":"2026-02-07T14:00:00+08:00","author":{"@type":"Person","name":"wwxdsg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://okelekaf01-cmd.github.io/posts/blog2/"},"publisher":{"@type":"Organization","name":"wwxdsg的个人博客","logo":{"@type":"ImageObject","url":"https://okelekaf01-cmd.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://okelekaf01-cmd.github.io/ accesskey=h title="wwxdsg的个人博客 (Alt + H)">wwxdsg的个人博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://okelekaf01-cmd.github.io/ title=主页><span>主页</span></a></li><li><a href=https://okelekaf01-cmd.github.io/projects/ title=个人项目><span>个人项目</span></a></li><li><a href=https://okelekaf01-cmd.github.io/posts/ title=博客><span>博客</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">预设代码、Skill 与 MCP</h1><div class=post-description>探讨AI应用开发中三种技术模式：预设代码、Skill和MCP的本质区别与适用场景</div><div class=post-meta><span title='2026-02-07 14:00:00 +0800 CST'>February 7, 2026</span>&nbsp;·&nbsp;<span>wwxdsg</span></div></header><div class=post-content><p>本文以我的开源项目 OpsMind 为例，探讨 AI 应用开发中三种常见的技术模式：预设代码、Skill 和 MCP，分析它们的本质区别与适用场景。</p><p>最近在开发 <strong>OpsMind</strong> —— 一个智能运营决策中枢，核心功能是通过自然语言对话进行数据分析和文件生成。在研究 AI 应用架构时，我接触到了 <strong>Skill</strong> 和 <strong>MCP</strong> 两个概念。
起初我有些困惑：我的项目也能通过对话生成文件，这和 MCP 有什么区别？预设代码算不算 Skill 技术？这些技术和提示词工程又是什么关系？</p><h2 id=我的现状预设代码模式>我的现状：预设代码模式<a hidden class=anchor aria-hidden=true href=#我的现状预设代码模式>#</a></h2><h3 id=项目架构>项目架构<a hidden class=anchor aria-hidden=true href=#项目架构>#</a></h3><p>OpsMind 目前的核心是一个 <code>DataAnalysisEngine</code> 类，所有功能都硬编码在类方法中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DataAnalysisEngine</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;数据分析引擎类&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_charts</span>(self, df, chart_types):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;生成图表&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;histogram&#34;</span> <span style=color:#f92672>in</span> chart_types:
</span></span><span style=display:flex><span>            plt<span style=color:#f92672>.</span>hist(<span style=color:#f92672>...</span>)      <span style=color:#75715e># 直方图</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;scatter&#34;</span> <span style=color:#f92672>in</span> chart_types:
</span></span><span style=display:flex><span>            plt<span style=color:#f92672>.</span>scatter(<span style=color:#f92672>...</span>)    <span style=color:#75715e># 散点图</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;heatmap&#34;</span> <span style=color:#f92672>in</span> chart_types:
</span></span><span style=display:flex><span>            sns<span style=color:#f92672>.</span>heatmap(<span style=color:#f92672>...</span>)    <span style=color:#75715e># 热力图</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># ... 更多图表类型</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_tables</span>(self, df, table_types):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;生成表格&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;basic_stats&#34;</span> <span style=color:#f92672>in</span> table_types:
</span></span><span style=display:flex><span>            df<span style=color:#f92672>.</span>describe()<span style=color:#f92672>.</span>to_excel(<span style=color:#f92672>...</span>)    <span style=color:#75715e># 统计表</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;pivot&#34;</span> <span style=color:#f92672>in</span> table_types:
</span></span><span style=display:flex><span>            df<span style=color:#f92672>.</span>pivot_table(<span style=color:#f92672>...</span>)<span style=color:#f92672>.</span>to_excel(<span style=color:#f92672>...</span>)  <span style=color:#75715e># 透视表</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># ... 更多表格类型</span>
</span></span></code></pre></div><h3 id=执行流程>执行流程<a hidden class=anchor aria-hidden=true href=#执行流程>#</a></h3><p>用户说"帮我分析销售数据并生成图表"，整个流程如下：</p><pre tabindex=0><code>┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  用户输入   │ ──→ │  LLM 判断   │ ──→ │  调用预设   │ ──→ │  生成文件   │
│             │     │    意图     │     │    函数     │     │             │
└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘
</code></pre><p>LLM 的作用是判断用户想要什么类型的图表/表格，然后调用对应的 Python 函数执行。</p><h3 id=这种模式的特点>这种模式的特点<a hidden class=anchor aria-hidden=true href=#这种模式的特点>#</a></h3><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>开发简单，逻辑清晰</td><td>功能固定，扩展需改代码</td></tr><tr><td>性能好，无额外开销</td><td>无法被其他 AI 应用复用</td></tr><tr><td>功能可控，调试方便</td><td>所有功能耦合在一起</td></tr></tbody></table><p>我把这种模式称为<strong>预设代码模式</strong>——功能写死在代码里，调用时直接执行。</p><hr><h2 id=skill-技术动态能力注入>Skill 技术：动态能力注入<a hidden class=anchor aria-hidden=true href=#skill-技术动态能力注入>#</a></h2><h3 id=什么是-skill>什么是 Skill<a hidden class=anchor aria-hidden=true href=#什么是-skill>#</a></h3><p>Skill 是一种<strong>运行时动态加载能力</strong>的模式。与预设代码不同，Skill 不是把所有功能都写死在启动时加载，而是根据用户需求，按需激活对应的能力模块。</p><h3 id=如果用-skill-重构-opsmind>如果用 Skill 重构 OpsMind<a hidden class=anchor aria-hidden=true href=#如果用-skill-重构-opsmind>#</a></h3><pre tabindex=0><code>skills/
├── data_analysis/
│   └── skill.md          # 数据分析能力
├── chart_generation/
│   └── skill.md          # 图表生成能力
└── table_export/
    └── skill.md          # 表格导出能力
</code></pre><p>每个 Skill 文件包含：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-markdown data-lang=markdown><span style=display:flex><span># 图表生成 Skill
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>## 触发条件
</span></span></span><span style=display:flex><span>用户要求生成图表、可视化数据时激活
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>## Prompt 模板
</span></span></span><span style=display:flex><span>你是一个数据可视化专家，可以生成以下图表：
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 直方图：调用 generate_histogram(data, column)
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 散点图：调用 generate_scatter(data, x_col, y_col)
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 热力图：调用 generate_heatmap(data, columns)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>## 工具定义
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> generate_histogram(data, column): 生成指定列的直方图
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> generate_scatter(data, x_col, y_col): 生成散点图
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> generate_heatmap(data, columns): 生成相关性热力图
</span></span></code></pre></div><h3 id=执行流程对比>执行流程对比<a hidden class=anchor aria-hidden=true href=#执行流程对比>#</a></h3><p><strong>预设代码模式：</strong></p><pre tabindex=0><code>启动时加载所有功能 → 用户提问 → LLM 选择函数 → 执行
</code></pre><p><strong>Skill 模式：</strong></p><pre tabindex=0><code>启动时加载基础能力 → 用户提问 → 识别需要哪个 Skill → 动态注入 Skill → LLM 使用 Skill 中的工具 → 执行
</code></pre><h3 id=与预设代码的对比>与预设代码的对比<a hidden class=anchor aria-hidden=true href=#与预设代码的对比>#</a></h3><table><thead><tr><th>维度</th><th>预设代码</th><th>Skill</th></tr></thead><tbody><tr><td>加载时机</td><td>启动时全部加载</td><td>运行时按需加载</td></tr><tr><td>Prompt 位置</td><td>固定在代码里</td><td>动态注入上下文</td></tr><tr><td>扩展方式</td><td>修改源代码</td><td>添加 Skill 文件</td></tr><tr><td>隔离性</td><td>功能耦合</td><td>模块独立</td></tr><tr><td>复用性</td><td>仅限本项目</td><td>可跨项目复用</td></tr></tbody></table><p><strong>我的理解</strong>：Skill 本质上是把"能力"抽象成可插拔的模块，让 AI Agent 能够根据任务动态组装自己的能力集。</p><hr><h2 id=mcp跨应用工具共享协议>MCP：跨应用工具共享协议<a hidden class=anchor aria-hidden=true href=#mcp跨应用工具共享协议>#</a></h2><h3 id=什么是-mcp>什么是 MCP<a hidden class=anchor aria-hidden=true href=#什么是-mcp>#</a></h3><p>MCP（Model Context Protocol）是 Anthropic 推出的开放协议，让 AI 应用能够调用外部工具。与 Skill 不同，MCP 关注的是<strong>跨应用的能力共享</strong>。</p><h3 id=如果用-mcp-重构-opsmind>如果用 MCP 重构 OpsMind<a hidden class=anchor aria-hidden=true href=#如果用-mcp-重构-opsmind>#</a></h3><p>我可以把数据分析能力封装成 MCP Server：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># mcp_server.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> mcp <span style=color:#f92672>import</span> Server
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>server <span style=color:#f92672>=</span> Server(<span style=color:#e6db74>&#34;opsmind-data-analysis&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@server.tool</span>(<span style=color:#e6db74>&#34;analyze_excel&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>analyze_excel</span>(file_path: str, query: str) <span style=color:#f92672>-&gt;</span> dict:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    分析 Excel 文件并返回结果
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Args:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        file_path: Excel 文件路径
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        query: 分析需求描述
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        包含分析结果的字典
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>read_excel(file_path)
</span></span><span style=display:flex><span>    <span style=color:#75715e># 分析逻辑...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {<span style=color:#e6db74>&#34;result&#34;</span>: analysis_result}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@server.tool</span>(<span style=color:#e6db74>&#34;generate_chart&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_chart</span>(data_path: str, chart_type: str, columns: list) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    生成图表并返回文件路径
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Args:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        data_path: 数据文件路径
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        chart_type: 图表类型 (histogram/scatter/heatmap)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        columns: 要分析的列名
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    Returns:
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        生成的图表文件路径
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 图表生成逻辑...</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chart_path
</span></span></code></pre></div><h3 id=mcp-的核心价值>MCP 的核心价值<a hidden class=anchor aria-hidden=true href=#mcp-的核心价值>#</a></h3><pre tabindex=0><code>┌─────────────────────────────────────────────────────────────┐
│                        MCP 生态                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐      │
│   │   Claude    │   │   Cursor    │   │    Trae     │      │
│   │   (Client)  │   │   (Client)  │   │   (Client)  │      │
│   └──────┬──────┘   └──────┬──────┘   └──────┬──────┘      │
│          │                 │                 │              │
│          └─────────────────┼─────────────────┘              │
│                            │                                │
│                            ▼                                │
│                   ┌─────────────────┐                       │
│                   │   MCP Protocol  │                       │
│                   └────────┬────────┘                       │
│                            │                                │
│          ┌─────────────────┼─────────────────┐              │
│          │                 │                 │              │
│          ▼                 ▼                 ▼              │
│   ┌─────────────┐   ┌─────────────┐   ┌─────────────┐      │
│   │ OpsMind     │   │  文件系统   │   │  数据库     │      │
│   │ (Server)    │   │  (Server)   │   │  (Server)   │      │
│   └─────────────┘   └─────────────┘   └─────────────┘      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre><p>这样，任何支持 MCP 的 AI 应用都能直接使用 OpsMind 的数据分析工具，无需重复开发。</p><h3 id=与-skill-的对比>与 Skill 的对比<a hidden class=anchor aria-hidden=true href=#与-skill-的对比>#</a></h3><table><thead><tr><th>维度</th><th>Skill</th><th>MCP</th></tr></thead><tbody><tr><td>作用范围</td><td>单个 AI 应用内部</td><td>跨应用共享</td></tr><tr><td>工具位置</td><td>应用内</td><td>独立进程</td></tr><tr><td>协议标准</td><td>无统一标准</td><td>统一开放协议</td></tr><tr><td>适用场景</td><td>能力模块化</td><td>工具生态化</td></tr><tr><td>开发成本</td><td>较低</td><td>需要实现协议</td></tr></tbody></table><p><strong>我的理解</strong>：MCP 解决的是"工具孤岛"问题——让不同 AI 应用能够共享同一套工具，而不是每个应用都重复开发。</p><hr><h2 id=三者的本质区别>三者的本质区别<a hidden class=anchor aria-hidden=true href=#三者的本质区别>#</a></h2><h3 id=架构对比图>架构对比图<a hidden class=anchor aria-hidden=true href=#架构对比图>#</a></h3><pre tabindex=0><code>┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  【预设代码】                                                    │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    AI 应用                               │  │
│   │  ┌─────────┐  ┌─────────┐  ┌─────────┐                 │  │
│   │  │ 功能 A  │  │ 功能 B  │  │ 功能 C  │  ← 全部硬编码    │  │
│   │  └─────────┘  └─────────┘  └─────────┘                 │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【Skill】                                                      │
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    AI 应用                               │  │
│   │  ┌─────────┐                                            │  │
│   │  │ 基础能力 │  ←── 动态加载 ───┐                         │  │
│   │  └─────────┘                  │                         │  │
│   └───────────────────────────────┼─────────────────────────┘  │
│                                   │                            │
│   ┌───────────────┬───────────────┴───────────────┐           │
│   │  Skill A      │  Skill B      │  Skill C      │           │
│   │  (按需加载)   │  (按需加载)   │  (按需加载)   │           │
│   └───────────────┴───────────────┴───────────────┘           │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【MCP】                                                        │
│                                                                 │
│   ┌─────────────────┐         ┌─────────────────┐             │
│   │    AI 应用 A    │         │    AI 应用 B    │             │
│   │   (MCP Client)  │         │   (MCP Client)  │             │
│   └────────┬────────┘         └────────┬────────┘             │
│            │                           │                       │
│            └───────────┬───────────────┘                       │
│                        │                                       │
│                        ▼                                       │
│            ┌─────────────────────┐                             │
│            │   MCP Protocol      │                             │
│            └──────────┬──────────┘                             │
│                       │                                        │
│         ┌─────────────┼─────────────┐                          │
│         │             │             │                          │
│         ▼             ▼             ▼                          │
│   ┌───────────┐ ┌───────────┐ ┌───────────┐                   │
│   │MCP Server │ │MCP Server │ │MCP Server │                   │
│   │   (工具1) │ │   (工具2) │ │   (工具3) │                   │
│   └───────────┘ └───────────┘ └───────────┘                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</code></pre><h3 id=核心差异总结>核心差异总结<a hidden class=anchor aria-hidden=true href=#核心差异总结>#</a></h3><table><thead><tr><th>维度</th><th>预设代码</th><th>Skill</th><th>MCP</th></tr></thead><tbody><tr><td><strong>设计目标</strong></td><td>快速实现功能</td><td>模块化能力管理</td><td>跨应用工具共享</td></tr><tr><td><strong>工具位置</strong></td><td>应用内部</td><td>应用内部</td><td>独立进程</td></tr><tr><td><strong>加载方式</strong></td><td>启动时全部加载</td><td>运行时按需加载</td><td>通过协议调用</td></tr><tr><td><strong>扩展方式</strong></td><td>修改源代码</td><td>添加 Skill 文件</td><td>连接新 Server</td></tr><tr><td><strong>共享能力</strong></td><td>无法共享</td><td>应用内共享</td><td>跨应用共享</td></tr><tr><td><strong>开发成本</strong></td><td>低</td><td>中</td><td>高</td></tr><tr><td><strong>适用规模</strong></td><td>小型项目</td><td>中型项目</td><td>大型生态</td></tr></tbody></table><hr><h2 id=提示词与执行层的关系>提示词与执行层的关系<a hidden class=anchor aria-hidden=true href=#提示词与执行层的关系>#</a></h2><h3 id=一个关键问题>一个关键问题<a hidden class=anchor aria-hidden=true href=#一个关键问题>#</a></h3><p>在研究这些技术时，我曾有一个疑问：<strong>这些技术都可以算是集成的提示词吗？</strong></p><p>答案是：<strong>不完全是，但都和提示词相关。</strong></p><h3 id=分层理解>分层理解<a hidden class=anchor aria-hidden=true href=#分层理解>#</a></h3><pre tabindex=0><code>┌─────────────────────────────────────────────────────────┐
│                                                         │
│   ┌─────────────────────────────────────────────────┐   │
│   │              LLM（大语言模型）                    │   │
│   └─────────────────────────────────────────────────┘   │
│                          │                              │
│                          ▼                              │
│   ┌─────────────────────────────────────────────────┐   │
│   │         【提示词层】决定 LLM 知道什么             │   │
│   │                                                  │   │
│   │   - 告诉 LLM 有哪些能力可用                      │   │
│   │   - 告诉 LLM 如何调用这些能力                    │   │
│   │   - 告诉 LLM 参数格式和返回格式                  │   │
│   └─────────────────────────────────────────────────┘   │
│                          │                              │
│                          ▼                              │
│   ┌─────────────────────────────────────────────────┐   │
│   │         【执行层】决定实际做什么                  │   │
│   │                                                  │   │
│   │   - 预设代码：应用内的 Python 函数               │   │
│   │   - Skill：应用内的模块化函数                    │   │
│   │   - MCP：外部独立进程                           │   │
│   └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre><h3 id=以-opsmind-为例>以 OpsMind 为例<a hidden class=anchor aria-hidden=true href=#以-opsmind-为例>#</a></h3><p><strong>预设代码模式：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 提示词部分：告诉 LLM 有哪些图表类型可选</span>
</span></span><span style=display:flex><span>prompt <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>【可选图表类型】
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- histogram: 直方图 - 查看数值分布
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- scatter: 散点图 - 查看变量关系
</span></span></span><span style=display:flex><span><span style=color:#e6db74>- heatmap: 热力图 - 查看特征相关性
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 执行部分：Python 代码直接执行</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;histogram&#34;</span> <span style=color:#f92672>in</span> chart_types:
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>hist(<span style=color:#f92672>...</span>)  <span style=color:#75715e># ← 这不是提示词，是真正的代码执行</span>
</span></span></code></pre></div><p><strong>Skill 模式：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-markdown data-lang=markdown><span style=display:flex><span>&lt;!-- skill.md - 这部分会转换成提示词注入给 LLM --&gt;
</span></span><span style=display:flex><span># 图表生成 Skill
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>你是一个数据可视化专家，可以生成以下图表：
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 直方图：调用 generate_histogram(data, column)
</span></span><span style=display:flex><span><span style=color:#66d9ef>-</span> 散点图：调用 generate_scatter(data, x_col, y_col)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;!-- 实际执行的函数定义在别处 --&gt;
</span></span></code></pre></div><p><strong>MCP 模式：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># MCP Server 定义工具</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@server.tool</span>(<span style=color:#e6db74>&#34;generate_chart&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate_chart</span>(data_path: str, chart_type: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;生成图表并返回文件路径&#34;&#34;&#34;</span>  <span style=color:#75715e># ← 这个描述会变成提示词</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 实际执行代码</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chart_path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># LLM 收到的提示词：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 你可以使用以下工具：</span>
</span></span><span style=display:flex><span><span style=color:#75715e># - generate_chart: 生成图表，参数：data_path, chart_type</span>
</span></span></code></pre></div><h3 id=形象比喻>形象比喻<a hidden class=anchor aria-hidden=true href=#形象比喻>#</a></h3><table><thead><tr><th>概念</th><th>比喻</th><th>作用</th></tr></thead><tbody><tr><td><strong>提示词</strong></td><td>菜单</td><td>告诉客人（LLM）有什么菜</td></tr><tr><td><strong>预设代码/Skill/MCP</strong></td><td>厨房</td><td>真正做菜的地方</td></tr></tbody></table><p><strong>关键理解</strong>：</p><ul><li>提示词是 LLM 的"说明书"——告诉它能做什么</li><li>预设代码/Skill/MCP 是执行层——真正干活的代码</li><li>这三种技术都<strong>依赖提示词</strong>让 LLM 知道有什么能力可用，但<strong>不是提示词本身</strong></li></ul><hr><h2 id=技术选型建议>技术选型建议<a hidden class=anchor aria-hidden=true href=#技术选型建议>#</a></h2><h3 id=场景匹配>场景匹配<a hidden class=anchor aria-hidden=true href=#场景匹配>#</a></h3><table><thead><tr><th>场景</th><th>推荐模式</th><th>理由</th></tr></thead><tbody><tr><td>快速开发 MVP</td><td>预设代码</td><td>开发成本低，迭代快</td></tr><tr><td>功能相对固定</td><td>预设代码</td><td>无需复杂架构</td></tr><tr><td>需要模块化扩展</td><td>Skill</td><td>能力可插拔，易维护</td></tr><tr><td>多团队协作开发</td><td>Skill</td><td>模块独立，职责清晰</td></tr><tr><td>需要跨应用共享工具</td><td>MCP</td><td>一次开发，多处使用</td></tr><tr><td>构建工具生态</td><td>MCP</td><td>开放协议，生态共赢</td></tr></tbody></table><h3 id=opsmind-的演进方向>OpsMind 的演进方向<a hidden class=anchor aria-hidden=true href=#opsmind-的演进方向>#</a></h3><p>目前 OpsMind 使用预设代码模式，对于单一应用来说已经足够。但未来可以考虑：</p><pre tabindex=0><code>┌─────────────────────────────────────────────────────────────┐
│                    OpsMind 架构演进                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  第一阶段：预设代码（当前）                                   │
│  ├── 快速实现核心功能                                        │
│  ├── 验证产品价值                                            │
│  └── 积累用户反馈                                            │
│                                                             │
│  第二阶段：引入 Skill                                        │
│  ├── 模块化现有功能                                          │
│  ├── 支持第三方 Skill 扩展                                   │
│  └── 提升可维护性                                            │
│                                                             │
│  第三阶段：MCP Server                                        │
│  ├── 开放数据分析能力给其他 AI 应用                          │
│  ├── 接入 MCP 生态                                           │
│  └── 构建工具生态                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre><h3 id=组合使用>组合使用<a hidden class=anchor aria-hidden=true href=#组合使用>#</a></h3><p>三者并非互斥，可以组合使用：</p><pre tabindex=0><code>AI 应用 → Skill（动态加载能力）→ MCP Client → MCP Server（调用外部工具）
</code></pre><p>例如：</p><ul><li>OpsMind 作为 AI 应用</li><li>使用 Skill 管理内部能力模块</li><li>通过 MCP Client 连接外部工具（如数据库、文件系统）</li><li>同时作为 MCP Server 对外提供服务</li></ul><hr><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><h3 id=核心观点>核心观点<a hidden class=anchor aria-hidden=true href=#核心观点>#</a></h3><ol><li><p><strong>预设代码</strong>：功能写死在代码里，简单直接，适合快速开发和功能固定的场景。</p></li><li><p><strong>Skill</strong>：动态能力注入，按需加载，适合模块化设计和需要扩展的场景。</p></li><li><p><strong>MCP</strong>：跨应用工具共享，开放协议，适合构建工具生态和跨应用复用。</p></li><li><p><strong>提示词与执行层</strong>：提示词是 LLM 的"说明书"，预设代码/Skill/MCP 是真正干活的"执行层"，两者配合才能让 AI 应用具备实际能力。</p></li></ol><h3 id=架构演进路径>架构演进路径<a hidden class=anchor aria-hidden=true href=#架构演进路径>#</a></h3><pre tabindex=0><code>预设代码 → Skill → MCP
   ↓         ↓        ↓
 功能固定  能力模块化  工具生态化
   ↓         ↓        ↓
 单应用内   单应用内   跨应用共享
   ↓         ↓        ↓
改代码扩展 加文件扩展 连接新Server
</code></pre><h3 id=最后的话>最后的话<a hidden class=anchor aria-hidden=true href=#最后的话>#</a></h3><p>没有最好的架构，只有最适合的架构。理解每种模式的适用场景，才能做出正确的技术选型。</p><p>对于 OpsMind 这样的项目，从预设代码开始是正确的选择——先验证价值，再考虑架构演进。当功能逐渐丰富、用户需求多样化时，再引入 Skill 和 MCP，逐步构建更开放、更可扩展的架构。</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://okelekaf01-cmd.github.io/tags/ai/>AI</a></li><li><a href=https://okelekaf01-cmd.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/>架构设计</a></li><li><a href=https://okelekaf01-cmd.github.io/tags/%E6%8A%80%E6%9C%AF%E6%A8%A1%E5%BC%8F/>技术模式</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://okelekaf01-cmd.github.io/>wwxdsg的个人博客</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>